% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/LASSO_lmls.R
\name{lasso_lmls}
\alias{lasso_lmls}
\title{Cross validation function for a LASSO model}
\usage{
lasso_lmls(location, scale = ~1, data, k_fold = 10, steps = 20, const = 1e-06)
}
\arguments{
\item{location}{A two-sided formula with the response variable on the LHS
and the predictor for the mean on the RHS.}

\item{scale}{A one-sided formula with the predictor for the standard
deviation on the RHS.}

\item{data}{A data frame (or list or environment) in which to evaluate
the \code{location} and \code{scale} formulas.}

\item{k_fold}{The amount of folds data is split into. Each fold is once used
as validation set while the rest serves as training data. A higher
number of folds increases the computational time but yields more
accurate results for the loss.}

\item{steps}{The number of lambda values that the model will be run on. A higher
number of steps will increase the computational time but yields more
accurate results for the optimal lambda values.}

\item{const}{Refers to the constant in lmls() that is used in the quadratic
approximation for the penalty term.}
}
\value{
A fitted linear model for location and scale as an \code{lmls} S3 object.
The object has at least the following entries:
\itemize{
\item \code{y}: the response vector
\item \code{x}: design matrix for the location variables
\item \code{z}: design matrix for the scale variables
\item \code{lasso}: binary, TRUE when model is lasso
\item \code{lambda}: optimal lambdas as a list with the names \code{location}
and \code{scale}
\item \code{const}: small constant that is used to approximate the
penalty term
\item \code{nobs}: the number of observations
\item \code{df}: the degrees of freedom
\item \code{df.residual}: the residual degrees of freedom
\item \code{call}: call of the model
\item \code{term}: model specifications as a list with the names \code{location}
and \code{scale}
\item \code{coefficients}: the regression coefficients as a list with the names
\code{location} and \code{scale}
\item \code{fitted.values}: the fitted values as a list with the names \code{location}
and \code{scale}
\item \code{residuals}: the response residuals
\item \code{vcov}: the variance-covariance matrices of the regression
coefficients as a list with the names \code{location} and \code{scale}
\item \code{chol_info_gamma}: cholesky decomposition for info_gamma(m)
\item \code{chol_info_beta}: cholesky decomposition for info_beta(m)
\item \code{iterations}: the number of iterations the Fisher scoring algorithm
took to converge
\item \code{loss}: the minimal loss that corresponds to optimal lambdas
\item \verb{loss matrix}: Outputs the loss values for each combination of lambdas
as a matrix. The rows are the location lambdas and the columns are the
scale lambdas.
}
}
\description{
The cross validation function uses the location-scale regression model and
evaluates for k-folds and a set of penalization terms lambda
(for each location and scale) the loss (negative log likelihood) for each set
of parameters. The combination of lambdas that over all folds yields the
smallest aggregated loss will be chosen as the optimal lambda parameters.
These are used to fit the returned model.
}
\examples{
library(asp22lasso)
n <- 1000
x1 <- runif(n)
x2 <- runif(n)
x3 <- runif(n)
y <- rnorm(n, 0 + 1 * x1 + 1 * x3, exp(-3 + 1 * x2 + 1 * x3))
data <- data.frame(matrix(c(y, x1, x2, x3), ncol = 4))
names(data) <- c("y", "X1", "X2", "X3")
m <- lasso_lmls(y ~ X1 + X3, ~ X2 + X3, data = data)
summary(m)
plot(m)
qqnorm(m)
}
